describe('Security Vulnerability Tests', () => {
  const testUrl = Cypress.config('baseUrl') || 'http://localhost:3000'

  beforeEach(() => {
    // Visit consumo page for testing
    cy.visit('/consumo')
  })

  describe('XSS Injection Prevention', () => {
    it('should sanitize script tags in search inputs', () => {
      const xssPayload = '<script>alert("XSS")</script>'
      
      // Look for search input or form fields
      cy.get('input[type="text"], input[type="search"], textarea').first().then($input => {
        if ($input.length > 0) {
          cy.wrap($input)
            .type(xssPayload)
            .should('not.contain.value', '<script>')
        }
      })
    })

    it('should escape HTML in displayed content', () => {
      const htmlPayload = '<img src="x" onerror="alert(1)">'
      
      cy.get('input[type="text"], input[type="search"], textarea').first().then($input => {
        if ($input.length > 0) {
          cy.wrap($input).type(htmlPayload)
          
          // Check that HTML is not executed in the DOM
          cy.get('body').should('not.contain.html', '<img src="x" onerror="alert(1)">')
        }
      })
    })

    it('should handle malicious URL parameters', () => {
      const maliciousParam = encodeURIComponent('<script>alert("XSS")</script>')
      
      cy.visit(`/consumo?search=${maliciousParam}`)
      
      // Check that the malicious script is not in the DOM
      cy.get('body').should('not.contain.html', '<script>alert("XSS")</script>')
    })
  })

  describe('Iframe Embedding Prevention', () => {
    it('should have X-Frame-Options header set to DENY', () => {
      cy.request('/consumo').then((response) => {
        expect(response.headers).to.have.property('x-frame-options')
        expect(response.headers['x-frame-options']).to.equal('DENY')
      })
    })

    it('should have CSP frame-src directive set to none', () => {
      cy.request('/consumo').then((response) => {
        const csp = response.headers['content-security-policy']
        expect(csp).to.include('frame-src')
        expect(csp).to.include("frame-src 'none'")
      })
    })
  })

  describe('Content Security Policy', () => {
    it('should have CSP header present', () => {
      cy.request('/consumo').then((response) => {
        expect(response.headers).to.have.property('content-security-policy')
      })
    })

    it('should restrict script-src to self and allowed domains', () => {
      cy.request('/consumo').then((response) => {
        const csp = response.headers['content-security-policy']
        expect(csp).to.include('script-src')
        expect(csp).to.include("'self'")
        // Should allow Supabase
        expect(csp).to.include('*.supabase.co')
      })
    })

    it('should not allow unsafe-inline for scripts', () => {
      cy.request('/consumo').then((response) => {
        const csp = response.headers['content-security-policy']
        expect(csp).to.not.include("'unsafe-inline'")
      })
    })

    it('should prevent loading external scripts', () => {
      // Attempt to inject external script via DOM manipulation
      cy.window().then((win) => {
        const script = win.document.createElement('script')
        script.src = 'https://evil.example.com/malicious.js'
        
        // This should be blocked by CSP
        let errorOccurred = false
        script.onerror = () => {
          errorOccurred = true
        }
        
        win.document.head.appendChild(script)
        
        // Wait a bit and check that the script didn't load
        cy.wait(1000).then(() => {
          expect(errorOccurred).to.be.true
        })
      })
    })
  })

  describe('Input Validation', () => {
    it('should handle special characters safely', () => {
      const specialChars = '&<>"\'/\\;=+'
      
      cy.get('input[type="text"], input[type="search"], textarea').first().then($input => {
        if ($input.length > 0) {
          cy.wrap($input)
            .clear()
            .type(specialChars)
            .should('have.value', specialChars)
        }
      })
    })

    it('should prevent SQL injection patterns', () => {
      const sqlPayloads = [
        "'; DROP TABLE users; --",
        "' OR '1'='1",
        "admin'--",
        "' UNION SELECT * FROM users --"
      ]
      
      sqlPayloads.forEach(payload => {
        cy.get('input[type="text"], input[type="search"], textarea').first().then($input => {
          if ($input.length > 0) {
            cy.wrap($input)
              .clear()
              .type(payload)
            
            // Submit if there's a form
            cy.get('form').first().then($form => {
              if ($form.length > 0) {
                cy.wrap($form).submit()
                
                // Check that no database errors are exposed
                cy.get('body')
                  .should('not.contain', 'SQL')
                  .should('not.contain', 'database error')
                  .should('not.contain', 'ORA-')
                  .should('not.contain', 'MySQL')
                  .should('not.contain', 'PostgreSQL')
              }
            })
          }
        })
      })
    })
  })

  describe('Additional Security Headers', () => {
    it('should have Strict-Transport-Security header in production', () => {
      // Only test HSTS in production environments
      if (testUrl.includes('https://')) {
        cy.request('/consumo').then((response) => {
          expect(response.headers).to.have.property('strict-transport-security')
          expect(response.headers['strict-transport-security']).to.include('max-age')
        })
      }
    })

    it('should have X-Content-Type-Options header', () => {
      cy.request('/consumo').then((response) => {
        // This might not be present in development but should be in production
        if (response.headers['x-content-type-options']) {
          expect(response.headers['x-content-type-options']).to.equal('nosniff')
        }
      })
    })
  })

  describe('Session Security', () => {
    it('should handle authentication tokens securely', () => {
      // Check that auth tokens are not exposed in URLs or localStorage
      cy.window().then((win) => {
        const localStorage = win.localStorage
        const sessionStorage = win.sessionStorage
        
        // Check that sensitive data is not stored insecurely
        Object.keys(localStorage).forEach(key => {
          const value = localStorage.getItem(key)
          expect(value).to.not.include('password')
          expect(value).to.not.include('secret')
        })
        
        Object.keys(sessionStorage).forEach(key => {
          const value = sessionStorage.getItem(key)
          expect(value).to.not.include('password')
          expect(value).to.not.include('secret')
        })
      })
    })

    it('should not expose sensitive information in error messages', () => {
      // Trigger a potential error by submitting invalid data
      cy.get('form').first().then($form => {
        if ($form.length > 0) {
          // Submit empty form or invalid data
          cy.wrap($form).submit()
          
          // Check that error messages don't expose sensitive info
          cy.get('body')
            .should('not.contain', 'stack trace')
            .should('not.contain', 'file path')
            .should('not.contain', 'database')
            .should('not.contain', 'server error')
        }
      })
    })
  })
})